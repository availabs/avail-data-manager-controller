#!/usr/bin/env node

/* eslint-disable @typescript-eslint/no-var-requires */

require("ts-node").register();
require("tsconfig-paths").register();

const { writeFileSync } = require("fs");
const { join, isAbsolute } = require("path");

const yargs = require("yargs/yargs");
const { hideBin } = require("yargs/helpers");

const dama_events = require("data_manager/events").default;
const logger = require("data_manager/logger").default;

const dama_host_id = require("constants/damaHostId").default;

const { runInDamaContext } = require("data_manager/contexts");

const {
  performExtract,
  reviseGisLayerTableDescriptors,
  loadGisDatasetLayer,
  integrateIntoDama,
  createMBTiles,
} = require("data_utils/gis/etl");

const {
  LayerName,
  flowline_dama_source_info,
  flowline_dama_view_info,
} = require("./domain");

const { pg_env, file_path, logging_level } = yargs(hideBin(process.argv))
  // .usage(
  // // "Usage $0 --pg_env [PostgresSQL Database] --etl_context_id [Etl Context ID]"
  // )
  .strict()
  .options({
    pg_env: {
      alias: "p",
      describe: "The PostgresSQL Database",
      demandOption: true,
    },

    file_path: {
      alias: "f",
      describe:
        "The location of the USGS National Hydrography Dataset Best Resolution (NHD) - New York FileGDB ZIP archive.",
      demandOption: true,
    },

    // etl_context_id: {
    // alias: "e",
    // describe: "The ETL Context ID of a previous run to resume.",
    // demandOption: true,
    // },

    logging_level: {
      alias: "l",
      describe: "The logging level",
      demandOption: false,
      default: "debug",
      choices: ["error", "warn", "info", "debug", "silly"],
    },
  }).argv;

const absolute_file_path = isAbsolute(file_path)
  ? file_path
  : join(process.cwd(), file_path);

logger.level = logging_level;

async function main() {
  const etl_context_id = await dama_events.spawnEtlContext(null, null, pg_env);

  logger.info(`==> etl_context_id: ${etl_context_id}`);

  const ctx = {
    meta: { pgEnv: pg_env, etl_context_id },
  };

  await runInDamaContext(ctx, async () => {
    try {
      const initial_event = {
        type: "usgs-national-hydrography-dataset/flowline/etl:INITIAL",
        payload: {
          file_path: absolute_file_path,
        },
        meta: { dama_host_id },
      };

      await dama_events.dispatch(initial_event);

      const {
        extract_done_data,
        table_descriptors: default_table_descriptors,
      } = await performExtract(file_path);

      const { workDirPath: workdir_path } = extract_done_data;

      const etl_context_id_fpath = join(workdir_path, "etl_context_id");
      writeFileSync(etl_context_id_fpath, `${etl_context_id}`);

      const flowline_table_descriptor = default_table_descriptors.find(
        ({ layerName }) => layerName === LayerName.FLOWLINE
      );

      if (!flowline_table_descriptor) {
        throw new Error(
          `INVARIANT BROKEN: The Flowline layer name is expected to be ${LayerName.FLOWLINE}.`
        );
      }

      const revised_flowline_table_descriptor = {
        ...flowline_table_descriptor,
        tableSchema: flowline_dama_view_info.table_schema,
        tableName: flowline_dama_view_info.table_name,
      };

      await reviseGisLayerTableDescriptors(revised_flowline_table_descriptor);

      await loadGisDatasetLayer(LayerName.FLOWLINE);

      const integrate_done_data = await integrateIntoDama(
        LayerName.FLOWLINE,
        flowline_dama_source_info,
        {
          ...flowline_dama_view_info,
          etl_context_id,
        }
      );

      await createMBTiles(flowline_dama_source_info.name);

      const final_event = {
        type: "usgs-national-hydrography-dataset/flowline/etl:FINAL",
        payload: integrate_done_data,
      };

      await dama_events.dispatch(final_event);
    } catch (err) {
      const { messages, stack } = err;

      const error_event = {
        type: "usgs-national-hydrography-dataset/flowline/etl:ERROR",
        payload: { messages, stack },
        error: true,
      };

      dama_events.dispatch(error_event);

      throw err;
    }
  });
}

main();
