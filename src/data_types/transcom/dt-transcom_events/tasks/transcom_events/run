#!/usr/bin/env node

/* eslint no-unused-expressions: 0, camelcase: 0 */

require("ts-node").register();

const { join } = require("path");

const yargs = require("yargs");

const { cliArgsSpec: pgEnvCliArgsSpec } = require("../../utils/PostgreSQL");

const {
  default: downloadTranscomEvents,
} = require("./tasks/downloadTranscomEvents");

const { default: loadTranscomEvents } = require("./tasks/loadTranscomEvents");

const transcom_events_dir = {
  type: "string",
  demand: false,
  describe: "Directory containing the downloaded TRANSCOM Events",
  default: join(__dirname, "../../../data/transcom/transcom_events"),
};

yargs
  .usage(
    "NOTE: These commands should not be used for normal nightly ETL. The are intended for rare use cases such as re-downloading/loading all TRANSCOM Events after a data schema change."
  )
  .parserConfiguration({
    "camel-case-expansion": false,
    "flatten-duplicate-arrays": false,
  })
  .command({
    command: "download",
    desc: "Download TRANSCOM Events",
    builder: {
      transcom_events_dir,

      start_timestamp: Object.assign({
        desc: "Start timestamp for Transcom Events.",
        demand: false,
        type: "string",
        describe: '"yyyy-mm-dd HH:MM:SS" format.',
      }),

      end_timestamp: {
        desc: "End timestamp for Transcom Events.",
        demand: true,
        type: "string",
        describe: '"yyyy-mm-dd HH:MM:SS" format.',
      },
    },
    handler: async ({
      start_timestamp,
      end_timestamp,
      transcom_events_dir,
    }) => {
      await downloadTranscomEvents(
        start_timestamp,
        end_timestamp,
        transcom_events_dir
      );
    },
  })
  .command({
    command: "load",
    desc: "Load downloaded TRANSCOM Events into the database",
    builder: {
      ...pgEnvCliArgsSpec,
      transcom_events_dir,
      table_schema: { type: "string", demand: true },
      table_name: { type: "string", demand: true },
    },
    handler: async ({
      pg_env,
      transcom_events_dir,
      table_schema,
      table_name,
    }) => {
      await loadTranscomEvents(
        pg_env,
        transcom_events_dir,
        table_schema,
        table_name
      );
    },
  })
  .demandCommand()
  .recommendCommands()
  .strict()
  .wrap(yargs.terminalWidth() / 1.618).argv;
